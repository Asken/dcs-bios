= DCS-BIOS User Guide
:toc: right
:icons: font
:toclevels: 2

Welcome to the DCS-BIOS User Guide.

This manual will explain how you can use DCS-BIOS to connect the clickable cockpit of a DCS: World aircraft to real-world hardware such as toggle switches, push buttons, rotary encoders, potentiometers and displays.

NOTE: If you want to add a new aircraft module or use your own software with DCS-BIOS, please refer to the Developer Guide.

== Introduction

So you want to build a panel for your DCS: World aircraft.
Whether you own a CNC machine or just a drill and a hot glue gun, you probably have some idea of how to use the tools available to you to mount controls such as push buttons, toggle switches, rotary encoders and potentiometers to a faceplate.

Once you have done that, you need a way to connect these controls to your DCS: World aircraft.
If that aircraft is the A-10C, read on to find out if DCS-BIOS is right for you.

=== Why Use DCS-BIOS?

The Home Cockpit section on the ED forums provides numerous examples to connect a switch panel to DCS.  And DCS-BIOS is just another means of doing the same thing.  Well actually it isn't and this is why you would want to use it.

.DCS-BIOS is "easy to use".

You've heard of people trying to learn Lua to write their own `Export.lua` file.  In most cases it was an exercise in frustration.  DCS-BIOS was produced so you don't have to worry about learning how to make your own lua files. *If you can connect two wires together, copy and paste text and follow step-by-step instructions, you can make a functioning panel.*

.DCS-BIOS is fully documented
We understand the frustrations when you try to build something or use something that has little or no instructions.   The DCS-BIOS Users Guide was produced to ensure you have the help you need.  It was written in easy to understand terminology aimed specifically at the novice.
You do not have to be a programmer or an electrical engineer to understand it.
After you read this User Guide, you will be able to connect a simple switch panel to DCS.

If you do have a programming background or simply want to know more, we have a Developer Guide that explains the internals in greater detail.

.DCS-BIOS will not impact your PC's performance
We did not notice any change in FPS when testing DCS-BIOS.
The additional computation it requires of your PC or its precious resources is negligible.

.DCS-BIOS will protect your switch panel from ED updates
So ED just broke my switch panel with their latest update.  DCS-BIOS will not let that happen.  In fact, DCS-BIOS was written just for that reason.  DCS-BIOS isolates your switch panel from the impact of any changes that Eagle Dynamics might introduce in an update.
In the extremely rare event that Eagle Dynamics does make a change that breaks something, we will ensure DCS-BIOS is immediately updated.   Your panels will always maintain their functionality.

.DCS-BIOS has an extremely efficient protocol design
Well what does that mean?  DCS-BIOS provided extremely fast communication with DCS. Your indicators, gauges and displays will never stutter or lag during a flurry of activity in the cockpit.  Pressing the signal lamp test button when spooling up the engines, or when half your caution lights panel is blinking after a SAM hit will have no impact on how fast your instruments respond.  

.DCS-BIOS covers everything.
There are a variety of interface boards that allow you to connect switches or rotary encoders or maybe both to DCS.  However DCS-BIOS extends way beyond any solution you might presently find. In Fact, it is the most comprehensive means of connecting your switch panel to any combination of your DCS aircrafts' buttons, switches, rotary encoders, potentiometers, push buttons, three way switches etc., etc.  In sort, there is nothing in the cockpit that DCS-BIOS does not cover.    

.DCS-BIOS makes use of the extremely popular Arduino ecosystem
DCS-BIOS was designed to work with the http://www.arduino.cc[Arduino family of microcontroller boards.]
Why?  The choice was easy.  By using a popular, general-purpose microcontroller development board instead of designing a custom PCB, we benefit from mass production and economics of scale. Suitable boards can be bought for about $25 from the official Arduino store.  100% compatible clones can be purchased on eBay or Amazon for just a few dollars.  

The popularity of the Arduino platform has also spawned a huge number of online tutorials, guides and blog posts.  There is an almost endless supply of support available.  In fact, you may also find numerous other uses for it.   

No matter what you wish to connect to your Arduino board, its more than probable someone out there has already done it and documented the results for you to use.



== Connecting your First Panel

After working through this section, you will have connected your first panel to DCS-BIOS.

=== Before you start

Make sure you have the following.

==== Skills

* Have a basic understanding of what an *electric circuit* is.
* Know what a *short-circuit* is, why it is a Bad Thing(TM) and how to avoid creating one by accident
* Have some way to make electrical connections. That can mean a "breadboard" and jumper wires, a soldering iron, a wire wrap tool, ...

==== Equipment
We will assume you have access to the following:

* A computer that has DCS: World installed, can access the internet and has a free USB port
* An Arduino board (the http://arduino.cc/en/Main/ArduinoBoardUno[Arduino UNO] is a good choice for beginners)
* A momentary on push button (the kind that stays on as long as your pressing it) 
* An LED (any colour and/or size) but not one of those super high powered, blind if you look at it, types. 
* A 220ohm 1/4 watt resistor
* 24 gauge wire or jumper wires

=== Step by Step
==== Step 1: Setting up DCS-BIOS

. Download the latest release of DCS-BIOS from https://github.com/dcs-bios/dcs-bios/releases[GitHub] and extract the ZIP file somewhere on your hard drive

. Open a new Explorer window (for example by opening "My Computer"), paste the following into the address bar and press return:
----
%USERPROFILE%\Saved Games\DCS
----
This should take you to your DCS configuration folder (it has several subfolders including `Logs` and `Missions`).  You are looking for the `scripts folder`.  (Not all configurations may have a scripts folder. Do not be concerned if you don`t have one.  Just follow these steps.)

There are two possible situations here.  The first one is if you don't see a `Scripts` subfolder.  If that's the case then you will copy the `Scripts` folder and all of its contents from where you extracted DCS-BIOS and paste it into `%USERPROFILE%\Saved Games\DCS`.  You can now skip to the next step.

If you do have a `Scripts` subfolder, then just copy the contents of the `Scripts` folder from where you extracted DCS-BIOS  and paste them into your existing `Scripts` folder.  But be advised that, if you have an existing scripts folder you may also have an existing `Export.lua` file.  You do not want to over write YOUR FILE with `Export.lua` file from the DCS-BIOS download.
Instead, you are going to make a small change to your own export.lua file.  This next part is important.  Do not use word processing software or the notepad that comes with Windows to make this change.  They may leave their own coding behind which could cause the file become corrupt.  Instead, you are going to download and install `Notepad++` This program is designed to edit files without contaminating them with extra coding.  
Go to http://notepad-plus-plus.org/download/v6.6.9.html
Once Notepad++ is installed you need to open your existing `Export.lua`.  Copy and paste the following line into it.  This line should be placed as the last line in your export.lua file:

[source,lua]
----
dofile(lfs.writedir()..[[Scripts\DCS-BIOS\BIOS.lua]])
----
Once you have completed that small change, save the file.  That is the only change you need to make.  Now we move on to the good stuff...connecting switches and LEDs.

==== Step 2: Connecting your LED and Push Button Switch

* Connect your push button switch to the Arduino board at pin 10 and pin GND (ground).

* Connect your LED and a 220 ohm 1/4 watt current limiting resistor in series between the Arduino pins 13 and GND (ground).

You have now completed all of the required wiring for you first switch panel.

==== Step 3: Set up the Arduino IDE
I imagine your next question is "what is an IDE".  The Arduino IDE is a program that you will download and install.  It is similar to a word processing program except this it is used to write small programs and upload them to your Arduino board.  You should probably read the page describing how to use the IDE on the Arduino web site.  It is very simple and you should have little to no difficulty understanding what to do.  So to continue...
   
* Download and install the Arduino IDE http://arduino.cc/en/Main/Software[from the Arduino website.]

* Download the https://github.com/dcs-bios/dcs-bios-arduino-library/releases[DCS-BIOS Arduino library] from GitHub.
You do not have to extract it.
+
. Start the Arduino IDE
. Click `Sketch -> Import Library -> Add Library...` and select the ZIP file you downloaded
. Close and re-open your Arduino IDE

==== Step 4: Create a program for your Arduino board

Congratulations, you have completed all of the one-time setup steps.
From now on any panel that you create will only require you to complete steps  4 and 5.

In this step, you are going to create a program for your Arduino board.
Each program you create will use a basic template that we have provided. This template automatically reads the state of your connected switches and reports any changes to DCS-BIOS which then updates the switches of your DCS aircraft.
 
This template is also responsible for automatically gathering output data from DCS.  You can use this data to make gauges function, displays work or indicator lights to light up.  We will provide you with several examples. 


NOTE: Arduino programs are also called "sketches".

Click `File -> Examples -> DcsBios -> TemplateSketch` to open the template program that comes with the DCS-BIOS Arduino library.

. Open the reference documentation in a browser of your choice by double-clicking the file `protocol-reference.html`.  It is located in the `doc` folder in your DCS-BIOS download.
. If you see a red warning followed by a bunch of nonsense, you need to enable JavaScript in your web browser and reload the page.

The reference documentation lists every switch, push button and rotary knob that DCS-BIOS knows about.
Also provided are "filters" that you can use to show only what you want to look at.  For example, I want to see only those controls that belong to the Up Front Controller.  Type `UFC` into the `Category Filter` box.

The first line is the Master Caution Light.  Copy this line of code and paste it into the sketch as shown.  The contents of this line, for the most part, will not mean much to you.  Just make sure you copy the *entire line*. The Arduino/DCS-BIOS uses that information and thats basically all you need to know. What you do need to pay attention to is the notation highlighted in italic red.  

In the reference documentation, `PIN` is highlighted in red in the example code.
That means once you finished pasting this line into the Arduino IDE you will have to replace that with the pin number you have connected the LED to.

In this example sketch you are writing, replace `PIN` with `13` so you end up with this:
[source,c++]
----
DcsBios::LED masterCaution(0x108e, 0x0008, 13);
----

Now scroll down to the `UFC_MASTER_CAUTION / Master Caution Reset` entry.
This represents the push button that resets the master caution warning.

In the reference documentation, you see it has example code for a `DcsBios::Switch2`, which is used for toggle switches and push buttons.
As you did with the Master Caution Light, copy the example code snippet and paste it into your sketch.
We connected the push button to pin `10` earlier, so replace `PIN` with `10`.

Now the start of your template program should look like this:
[source,c++]
----
#include <DcsBios.h>
#include <Servo.h>

/**** Make your changes after this line ****/

DcsBios::LED masterCaution(0x108e, 0x0008, 13);
DcsBios::Switch2 ufcMasterCaution("UFC_MASTER_CAUTION", 10);

/**** In most cases, you do not have to change anything below this line ****/

----

Your program is finished.
Click `File -> Save As` to save it under a new name.

NOTE: The Arduino IDE prevents you from saving changes to a library example.
You will have to save your changes under a new name.

==== Step 5: Copy your program to your Arduino board

Now that your Arduino sketch is done, you need to load it onto your board.

The details may vary for different Arduino boards but for the most part they follow the same basic routine.  If its the UNO you will need to say what board you are using and what COM port its on.  If you don't know check the Devices and Printers page in the Control Panel.  It will show the UNO and what COM port its on.

The Arduino website has http://arduino.cc/en/Guide/HomePage[step-by-step instructions for each board.]  You should read this for your specific board.  Its not hard stuff by any means but you should know what it is you are doing.

After loading your program onto your Arduino board, you can close the Arduino software.

==== Step 6: Test your new panel

DCS-BIOS comes with a script that automatically connects a serial port to DCS/Arduino Board/Panel.  This is what your Arduino board uses to talk/listen to the PC.

Now its time to open Notepad++ again.  This time you are going to open `connect-serial-port.cmd` from your DCS-BIOS download.  Locate the line that starts with `COMPORT=`.
Replace the existing number with the COM port number you used to program your Arduino board and save the file.

Now double-click `connect-serial-port.cmd`.
A console window should pop up.
Leave it open.

You can now start DCS and try your new panel in action!

You can make any panel you like using the standard template that we provided as the outline for your sketch.  Its just a matter of adding the lines of code from the reference documentation for the switches you wish to use and connecting the appropriate switch type to the appropriate pin number on the Arduino board.  If your intent is to also add displays you will need to have additional knowledge working with Arduino. There are so many type of displays that it is beyond the scope of the Users Manual to give instruction on every available type of display. We have provided the basic structure for a novice to create a switch panel using the Arduino platform with very little further knowledge of Arduino, DCS or Lua.



== A Closer Look at The DCS-BIOS Arduino Library

This tutorial will show you how to read the DCS-BIOS reference documentation to create a sketch for any panel in the cockpit.

It will cover all of the different control types that are supported by the Arduino library.  The information provided at this point will require some level of knowledge with Arduino programming.

=== The MasterCaution Example Sketch

This section takes a closer look at the different parts of the MasterCaution example sketch. 

[source,c++]
----
#include <DcsBios.h> // <1>
#include <Servo.h>

/* Declare a Master Caution Reset button on pin 10 */ // <2>
DcsBios::Switch2 masterCautionBtn("UFC_MASTER_CAUTION", 10);
/* Make the LED connected to pin 13 into a Master Caution Light */
DcsBios::LED mcLed(0x108e, 0x0008, 13);

/* Instantiate a ProtocolParser object to parse the DCS-BIOS export stream */
DcsBios::ProtocolParser parser; // <3>

void setup() {
  Serial.begin(500000); // <4>
}

/*
Your main loop needs to pass data from the DCS-BIOS export
stream to the parser object you instantiated above.

It also needs to call DcsBios::PollingInput::pollInputs()
to detect changes in the state of connected controls and
pass them on to DCS.
*/
void loop() {
  // feed incoming data to the parser
  while (Serial.available()) {
      parser.processChar(Serial.read()); // <5>
  }
  
  // poll inputs
  DcsBios::PollingInput::pollInputs(); // <6>
}

/*
You need to define
void sendDcsBiosMessage(const char* msg, const char* arg)
so that the string msg, followed by a space, the string arg
and a newline gets sent to the DCS-BIOS import stream.

In this example we send it to the serial port, so you need to
run socat to read the data from the serial port and send it
over UDP to DCS-BIOS.

If you are using an Ethernet Shield, you would probably want
to send a UDP packet from this subroutine.
*/
void sendDcsBiosMessage(const char* msg, const char* arg) { // <7>
  Serial.write(msg);
  Serial.write(' ');
  Serial.write(arg);
  Serial.write('\n');
}

/*
This subroutine gets called every time a write access is received
from the export stream (you need to define it even if it
does nothing).

Use this to handle outputs which are not covered by the
DcsBios Arduino library (e.g. displays).
*/
void onDcsBiosWrite(unsigned int address, unsigned int value) { // <8>
  
}
----

<1> Include the neccessary header files.
This ensures that the Arduino IDE will bring in the required libraries during the compilation process.
Even if your sketch does not use the `ServoOutput` class you still have to include `Servo.h`.
Otherwise your sketch will not compile.

<2> Tell the library what types of controls are connected to your Arduino.
DCS-BIOS knows how to handle push buttons, toggle switches, rotary encoders, rotary switches, potentiometers, LEDs and servo motors.
If you want to use one of these control types, refer to the next section to learn how to read the reference documentation and find out what to put here.

<3> Create an object of type `DcsBios::ProtocolParser`.
We will need this later.

<4> In the `setup()` function, we set up the serial port to run at a speed of 500000 bps.
This setting needs to match the one in `connect-serial-port.cmd`.
500000 is the fastest the Arduino can handle and is the default.

<5> In `loop()`, we read data from the serial port and feed it to the `DcsBios::ProtocolParser` we created above.

<6> We also need to call `DcsBios::PollingInput::pollInputs()`.
This causes the DcsBios library to check the state of all connected inputs such as push buttons, rotary encoders, etc. and send a message to your DCS computer if they have changed.

<7> The DcsBios Arduino library expects you to supply a function called `sendDcsBiosMessage` that knows how to send a message to your DCS computer.
In this case, we simply write the message to the serial port.

<8> The DcsBios Arduino library calls `onDcsBiosWrite` whenever it receives data from DCS.
This is the place to handle output when the DcsBios library does not have a pre-made class that fits your needs, for example when you want to connect a display for a radio frequency.
Even when it is empty, this function must exist.
The compiler will complain otherwise.

=== Using the Reference Documentation
Recall the following part from the MasterCaution example:
[source,c++]
----
DcsBios::Switch2 masterCautionBtn("UFC_MASTER_CAUTION", 10);
DcsBios::LED masterCautionLED("MASTER_CAUTION", 13);
----

Unless you are doing something more advanced such as using something other than a serial port to talk to your DCS computer, this is the only part you need to modify.

Even without knowing much about DCS-BIOS, you might have guessed that this says there is a push button connected to pin 10 that should operate the master caution button and that the LED on pin 13 should light up then the master caution button does.

But how do you know what to put here for other controls?
You will have to consult the reference documentation.

==== Locating the Reference Documentation

The reference documentation is included in the `doc/` subdirectory in the DCS-BIOS download.
Simply double-click `protocol-reference.html` to open it in your web browser.

NOTE: If you see a red warning at the top of the page followed by a bunch of gibberish, you need to enable JavaScript and reload the page.

==== Controls
In your virtual cockpit you will find lots of toggle switches, buttons and rotary knobs.
DCS-BIOS refers to them as controls.

Each control is identified by a unique identifier and is associated with a category, which is usually the panel it is found on in the virtual cockpit.

Some knobs in your cockpit are represented as two separate controls.
For example, the volume controls on the A-10C intercom panel have one DCS-BIOS control for the volume and a separate for the mute function.

==== Finding the Control You Are Looking For

Use the search boxes at the top of the page to quickly find what you are looking for.
You can filter by category, identifier and description.

==== Input Interfaces

NOTE: To make sense of the following, switch the reference documentation to "advanced view".

Each DCS-BIOS control can support multiple _input interfaces_.
An _input interface_ allows you to control something in the cockpit by sending a message to DCS-BIOS.
For example, you can toggle the CICU switch in the A-10C by sending `AHCP_CICU TOGGLE`.

A message starts with the identifier of the control you want to manipulate, followed by a space, an _argument_, and a newline character.
Different input interfaces understand different arguments.

Depending on the type of input interface, the reference documentation will offer different pieces of example code.

.Types of input interfaces

set_state:: If a control supports the _set_state_ interface, its current state can be set by sending it a number as an argument.
For example, you can set the TACAN mode dial in the A-10C to the `A A REC` position by sending `TACAN_MODE 3`.
+
NOTE: The range of acceptable values is 0 to the maximum value of the control's first output.
+
The reference documentation will offer example code for a `DcsBios::RotarySwitch` and (in the case of two-position controls) a `DcsBios::Switch2`.

fixed_step:: If a control supports the _fixed_step_ interface, you can increase its position with an `INC` argument and decrease its position with an `DEC` argument.
+
The reference documentation will offer example code for a `DcsBios::RotaryEncoder`.

action:: This represents an action such as toggling a toggle switch or changing the X/Y digit of the TACAN channel.
+
The reference documentation will offer example code for a `DcsBios::ActionButton`.

variable_step:: If a control supports the _variable_step_ interface, you can increase or decrease its position by a certain amount by sending `+NUMBER` or `-NUMBER` as an argument, where `NUMBER` is an integer.
+
The reference documentation will offer example code for a `DcsBios::RotaryEncoder`.
The default step size is 3200.
You will need to experiment to get the right sensitivity.


==== Outputs

Each DCS-BIOS control can have multiple related _outputs_.
An _output_ represents a piece of information that is exported from DCS, for example the position of the flaps position indicator.

Outputs come in two types:

Integer outputs:: Most outputs are integers.
Each integer output has an associated maximum value and a minimum value of 0.
+
The reference documentation will offer code examples for `DcsBios::LED` and `DcsBios::ServoOutput` where appropriate.
+
The first code snippet for integer outputs is meant to be inserted into the `onDcsBiosWrite` function if the DCS-BIOS Arduino library cannot do what you want.
It shows you how to extract the value using the _mask_ and _shift_ values of the output.
+
NOTE: To learn about the meaning of the _address_, _mask_ and _shift_ value of an output, please refer to the developer guide.

String outputs:: Some values (such as radio frequencies) are exported as character strings.
The reference documentation will provide a code example that uses a `DcsBios::StringBuffer` to execute a piece of code whenever the value changes.
+
NOTE: Because there are many different types of displays (7-segment, character, graphical) and different ways to connect them to a microcontroller (direct, I2C, SPI), the DcsBios library does not include code to handle them.
For most common combinations of display type and connection method, you can find other Arduino libraries online that allow you to talk to them.


==== Copy and Paste Example Code

To use the example code from the reference documentation in your Arduino sketch, you first have to choose which code example to copy.
That depends on what type of control you want to connect.

For example, you might want to use a rotary switch for the TACAN mode dial in the A-10C and use the `DcsBios::RotarySwitch` code snippet. For the same control, you could also choose to use a rotary encoder.

After choosing a code example, copy it to your Arduino sketch (refer back to the MasterCaution example to see where to copy it) and replace all the parts in red with your own values (usually the pin numbers that this control is connected to).

Refer to the next section for more detailed information on the individual classes, including example circuits.


== Arduino Library Reference
=== ActionButton

[source,c++]
----
DcsBios::ActionButton(char* message, char* argument, char* pin)
----

The ActionButton class is used to send a single command to DCS when its input pin goes low.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
argument:: The argument that should be sent.
pin:: The number of the Arduino pin the button is connected to.

.Circuit
Connect a push button between the Arduino pin and ground.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::ActionButton ahcpCicuToggle("AHCP_CICU", "TOGGLE", PIN);
----

.Code Examples
[source,c++]
----
DcsBios::ActionButton ahcpCicuToggle("AHCP_CICU", "TOGGLE", 10); // <1>
DcsBios::ActionButton decTacanMode("TACAN_MODE", "DEC", 11); // <2>
----
<1> A button on pin 10 that toggles the CICU switch
<2> A button on pin 11 that moves the TACAN Mode dial one position to the left

=== Switch2

[source,c++]
----
DcsBios::Switch2(char* message, char pin)
----

The Switch2 class handles inputs that have two states, such as toggle switches and push buttons.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pin:: The number of the Arduino pin the button or switch is connected to

.Circuit
Connect the toggle switch or push button between the Arduino pin and ground.

.Reference Documentation Code Examples
[source,c++]
----
DcsBios::Switch2 ahcpCicu("AHCP_CICU", PIN);
----

[source,c++]
----
DcsBios::Switch2 ufcHack("UFC_HACK", PIN);
----

=== Switch3

[source,c++]
----
DcsBios::Switch3(char* message, char pinA, char pinB)
----

The Switch3 class handles inputs that have three states, such as three-position toggle switches or rotaries.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pinA:: The number of the Arduino pin that the *first switch position* is connected to
pinB:: The number of the Arduino pin that the *last switch position* is connected to

.Circuit
Connect your three-position toggle or rotary switch so that the first (left or down) position connects *pinA* to ground and the last (right or up) position connects *pinB* to ground.

The Switch3 class defaults to the center position, so (if your switch even has a pin for that) you don't have to connect it to anything.

.Reference Documentation Code Examples
[source,c++]
----
DcsBios::Switch3 aapSteer("AAP_STEER", PIN_A, PIN_B);
----

=== RotarySwitch

[source,c++]
----
DcsBios::RotarySwitch(char* message, const byte* pins, char numberOfPins);
----

The RotarySwitch class handles rotary switches.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pins:: An array of pin numbers that the rotary switch positions are connected to.
The first pin number corresponds to state 0 of the input, the second to state 1, etc.
numberOfPins:: The length of the array passed in the `pins` parameter.

.Circuit
Connect the rotary switch so that it connects the Arduino pin for the currently selected position to ground.

.Reference Documentation Code Examples
[source,c++]
----
const byte aapSteerptPins[3] = {PIN_0, ... ,PIN_2};
DcsBios::RotarySwitch aapSteerpt("AAP_STEERPT", aapSteerptPins, 3);
----

.Example
[source,c++]
----
// A rotary switch that controls the A-10C steerpoint mode (FLTPLAN / MARK / MISSION)
// is connected to digital pins 10, 11 and 12
const byte aapSteerptPins[3] = {10, 11, 12};
DcsBios::RotarySwitch aapSteerpt("AAP_STEERPT", aapSteerptPins, 3);
----

=== Potentiometer

[source,c++]
----
DcsBios::Potentiometer(char* message, char pin);
----

The Potentiometer class handles potentiometers connected to an analog pin.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pin:: The number of the pin that is connected to the potentiometer.

.Circuit
Connect the outer pins of the potentiometer to +5V and ground.
Connect the middle pin to the Arduino.

To reverse the direction, swap +5V and GND.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::Potentiometer cmscBrt("CMSC_BRT", PIN);
----

=== RotaryEncoder

[source,c++]
----
DcsBios::RotaryEncoder(const char* message, const char* decArg, const char* incArg, char pinA, char pinB);
----

The RotaryEncoder class handles standard rotary encoders.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
decArg:: The argument that should be sent when the encoder is turned one step to the left.
incArg:: The argument that should be sent when the encoder is turned one step to the right.
pinA:: The first pin that is connected to the encoder.
pinB:: The second pin that is connected to the encoder.

.Circuit
Rotary encoders usually have three pins (the ones with an integrated push button have two extra pins for the button).
Connect the left pin to Arduino pin A, the middle pin to ground and the right pin to Arduino pin B.

To reverse the direction, either swap decArg and incArg or swap pinA and pinB.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::RotaryEncoder tacan1("TACAN_1", "DEC", "INC", PIN_A, PIN_B);
----


=== LED

[source,c++]
----
DcsBios::LED(unsigned int address, unsigned int mask, char pin)
----

The LED class is used for indicator lights.

.Constructor Parameters
address:: The address of the integer output
mask:: The mask of the integer output
pin:: The number of the Arduino pin that the LED (and current-limiting resistor) are connected to

.Reference Documentation Code Example
[source,c++]
----
DcsBios::LED tacanTest(0x10ca, 0x0400, PIN);
----

=== ServoOutput

[source,c++]
----
DcsBios::ServoOutput (unsigned int address, char pin, int minPulseWidth, int maxPulseWidth)
----

The ServoOutput class handles standard "hobby servos".

.Constructor Parameters
address:: The address of the integer output
pin:: The number of the Arduino pin that is connected to the servo's control input
minPulseWidth:: The pulse width (in microseconds) that corresponds to the lowest servo position
maxPulseWidth:: The pulse width (in microseconds) that corresponds to the highest servo position

NOTE: A DCS-BIOS output value of 0 will be mapped to `minPulseWidth`, the maximum output value of 65535 will be mapped to `maxPulseWidth`.
You will have to choose these values so that the minimum and maximum positions are at the beginning and end of your gauge's scale.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::ServoOutput vvi(0x106e, PIN, 544, 2400);
----


=== StringBuffer

[source,c++]
----
DcsBios::StringBuffer<MAXLENGTH>(unsigned int address, void (*)(char*) callback)
----

The StringBuffer class is used to handle string outputs.

.Constructor Parameters
MAXLENGTH:: The maximum length of the string output
address:: The address of the string output
callback:: A function which accepts an argument of type `char*`.
This function will be called whenever the string output has changed.
It will be passed the new value as an argument.

.Reference Documentation Code Example
[source,c++]
----
void onUhfFrequencyChange(char* newValue) {
    /* your code here */
}
DcsBios::StringBuffer<7> uhfFrequencyBuffer(0x1170, onUhfFrequencyChange);
----

== Aircraft-Specific Notes
=== A-10C

==== CMSP, CMSC and UHF Frequency Export in external view

These values will not be updated by DCS when the cockpit is not rendered (e.g. in external view or HUD-only view).

The solution is to assign another viewport to these indicators (through MonitorSetup.lua), so they exist even when the cockpit is not shown.
You can make the viewport 1x1 pixels in size and place it outside of your visible screen area.
For example, if you have no monitor above the primary one, you could place the viewport at coordinates (0, -10).

==== Using a LED matrix for the Caution Lights

If you are building the Caution Lights panel, you probably don't want to use several Arduinos to get 48 output pins.
You want to use a LED matrix design instead.

Fortunately, the caution lights data is located in three consecutive 16-bit integers in the DCS-BIOS export address space.
The following code should get you started:

[source,c++]
----
void updateCautionLights(unsigned int address, unsigned int data) {
    unsigned char row = (address - 0x10c4) * 2;
    unsigned char column = 0;
    unsigned char i;
    bool is_on;
    for (i=0; i<16; i++) {
        is_on = data & 0x01;
        // set caution light state (row, column, is_on)
        data >>= 1;
        column++;
        if (column == 4) {
           row++;
           column = 0;
        }
    }
}
void onDcsBiosWrite(unsigned int address, unsigned int data) {
    if (address >= 0x10c4 && address <= 0x10c8) {
       updateCautionLights(address, data);
    }
}
----
